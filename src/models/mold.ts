import Ajv, { ValidateFunction } from 'ajv';
import { SCHEMA, DESCRIPTION } from './constants';
import { extractSchema } from './builder';
import { InstanceWithError, PayloadWithError } from './types';
import AjvErrors from 'ajv-errors';
import AjvKeywords from 'ajv-keywords';

export class Molder {
    private static ajv: Ajv = null;

    /**
     * instantiate
     *
     * Instantiate a class with using ajv to
     * validate and tranform the payload.
     * The validated payload will populate the instance.
     *
     * Example:
     *
     * class Account {
     *      @Required
     *      balance: integer;
     * }
     *
     * const instance = Molder.instantiate(Account, { balance: '1000', extraInfo: 'xxx' });
     *
     * instance: Account { balance: 1000 }
     *
     * @param token
     * @param payload
     */
    static instantiate<T extends Object>(token: { new (): T }, payload: any): T {
        const instance = Reflect.construct(token, []);
        Object.entries(this.validate(token, payload)).forEach(([key, value]) => {
            Reflect.set(instance, key, value);
        });
        return instance;
    }

    /**
     * instantiate with errors
     *
     * Same as `instantiate` but return errors rather than throwing them.
     *
     * @param token
     * @param payload
     */
    static instantiateWithErrors<T extends Object>(
        token: { new (): T },
        payload: any
    ): InstanceWithError<T> {
        const instance = Reflect.construct(token, []);
        const validated = this.validateWithErrors(token, payload);

        Object.entries(validated.payload).forEach(([key, value]) => {
            Reflect.set(instance, key, value);
        });

        return {
            instance,
            ...(validated.errors && { errors: validated.errors })
        };
    }

    /**
     * validate
     *
     * Use ajv to validate and tranform the payload.
     *
     * @param token
     * @param payload
     */
    static validate<T extends Function>(token: T, payload: any): any {
        const compiledSchema = this.getCompiledSchema(token);
        const value = compiledSchema(payload);
        if (!value) {
            const errors = [];
            const toTreat = [...compiledSchema.errors];
            while (toTreat.length > 0) {
                const current = toTreat.pop();
                errors.push(current);
                if (current && (current.params as any).errors) {
                    toTreat.push(...(current.params as any).errors);
                }
            }
            const message = Molder.getAjv().errorsText(errors);
            throw new Error(`error while validating ${token.name}: ${message}`);
        }
        return payload;
    }

    /**
     * validate with errors
     *
     * Same as `validate` but return errors rather than throwing them.
     *
     * @param token
     * @param payload
     */
    static validateWithErrors<T extends Function>(token: T, payload: any): PayloadWithError<any> {
        const value = this.getCompiledSchema(token)(payload);

        return {
            payload,
            ...(!value && {
                errors: Molder.getAjv().errorsText(this.getCompiledSchema(token).errors)
            })
        };
    }

    /**
     * Return the json schema
     *
     * @param token
     */
    static jsonSchema<T extends Function>(token: T): Record<string, any> {
        return extractSchema(token);
    }

    /**
     * getCompiledSchema
     *
     * Getter for the compiled schema generated by ajv.
     * The compile will be generated at the first call and
     * stored in the class metadata. The next calls will get
     * the compiled schema directly in the metadata.
     *
     * @param token
     * @param allErrors Used by `instantiateWithErrors` to return all errors
     */
    static getCompiledSchema(token: Function): ValidateFunction {
        let compiledSchema = Reflect.getOwnMetadata(SCHEMA, token);
        if (!compiledSchema) {
            const schema = extractSchema(token);
            compiledSchema = Molder.getAjv().compile(schema);
            Reflect.defineMetadata(SCHEMA, compiledSchema, token);
        }
        return compiledSchema;
    }

    /**
     * Return the global description of the model
     *
     * @param token
     */
    static getDescription(token: Function): string {
        return Reflect.getOwnMetadata(DESCRIPTION, token);
    }

    private static getAjv(): Ajv {
        if (!Molder.ajv) {
            Molder.ajv = new Ajv({
                removeAdditional: true,
                useDefaults: true,
                coerceTypes: true,
                allErrors: true
            });
            AjvErrors(Molder.ajv);
            AjvKeywords(Molder.ajv, ['transform']);
        }

        return Molder.ajv;
    }
}
